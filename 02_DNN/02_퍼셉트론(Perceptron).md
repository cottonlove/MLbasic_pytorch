# 02. 퍼셉트론(Perceptron)

인공 신경망은 수많은 머신 러닝 방법 중 하나이다.  인공 신경망을 복잡하게 쌓아 올린 딥 러닝이고, 이번 챕터에서는 초기의 인공 신경망인 퍼셉트론(Perceptron)에 대해서 이해합니다.



### 1. 퍼셉트론(Perceptron)

초기 형태의 인공 신경망으로 다수의 입력으로부터 하나의 결과를 내보내는 알고리즘입니다.

![image-20220211164724741](C:\Users\dbw21\AppData\Roaming\Typora\typora-user-images\image-20220211164724741.png)

는 입력값을 의미하며, W는 가중치(Weight), y는 출력값입니다. 그림 안의 원은 인공 뉴런에 해당됩니다. 

각각의 입력값에는 각각의 가중치가 존재하는데, 이때 가중치의 값이 크면 클수록 해당 입력 값이 중요하다는 것을 의미합니다.

각 입력값이 가중치와 곱해져서 인공 뉴런에 보내지고, 각 입력값과 그에 해당되는 가중치의 곱의 전체 합이 임계치(threshold)를 넘으면 종착지에 있는 인공 뉴런은 출력 신호로서 1을 출력하고, 그렇지 않을 경우에는 0을 출력합니다. 이러한 함수를 계단 함수(Step function)라고 하며, 아래는 그래프는 계단 함수의 하나의 예를 보여줍니다.

![image-20220211164751708](C:\Users\dbw21\AppData\Roaming\Typora\typora-user-images\image-20220211164751708.png)

이때 계단 함수에 사용된 이 임계치값을 수식으로 표현할 때는 보통 세타(Θ)로 표현합니다. 이를 식으로 표현하면 다음과 같습니다.

![image-20220211164806052](C:\Users\dbw21\AppData\Roaming\Typora\typora-user-images\image-20220211164806052.png)

단, 위의 식에서 임계치를 좌변으로 넘기고 편향 b(bias)로 표현할 수도 있습니다. 편향 b 또한 퍼셉트론의 입력으로 사용됩니다. 보통 그림으로 표현할 때는 입력값이 1로 고정되고 편향 b가 곱해지는 변수로 표현됩니다.

![image-20220211164819998](C:\Users\dbw21\AppData\Roaming\Typora\typora-user-images\image-20220211164819998.png)

이렇게 뉴런에서 출력값을 변경시키는 함수를 활성화 함수(Activation Function)라고 합니다. 초기 인공 신경망 모델인 퍼셉트론은 활성화 함수로 계단 함수를 사용하였지만, 그 뒤에 등장한 여러가지 발전된 신경망들은 계단 함수 외에도 여러 다양한 활성화 함수를 사용하기 시작했습니다. 사실 앞서 배운 시그모이드 함수나 소프트맥스 함수 또한 활성화 함수 중 하나입니다.

퍼셉트론을 배우기 전에 로지스틱 회귀를 먼저 배운 이유도 여기에 있습니다. 퍼셉트론의 활성화 함수는 계단 함수이지만 여기서 활성화 함수를 시그모이드 함수로 변경하면 방금 배운 퍼셉트론은 곧 이진 분류를 수행하는 로지스틱 회귀와 동일함을 알 수 있습니다.

다시 말하면 로지스틱 회귀 모델이 인공 신경망에서는 하나의 인공 뉴런으로 볼 수 있습니다. 로지스틱 회귀를 수행하는 인공 뉴런과 위에서 배운 퍼셉트론의 차이는 오직 활성화 함수의 차이입니다.

- 인공 뉴런 : ![image-20220211164858895](C:\Users\dbw21\AppData\Roaming\Typora\typora-user-images\image-20220211164858895.png)
- 위의 퍼셉트론(인공 뉴런 종류 중 하나) : ![image-20220211164908651](C:\Users\dbw21\AppData\Roaming\Typora\typora-user-images\image-20220211164908651.png)



### 2. 단층 퍼셉트론(Single-Layer Perceptron)

퍼셉트론은 단층 퍼셉트론과 다층 퍼셉트론으로 나누어지는데, 단층 퍼셉트론은 값을 보내는 단계과 값을 받아서 출력하는 두 단계로만 이루어집니다. 이때 이 각 단계를 보통 층(layer)라고 부르며, 이 두 개의 층을 입력층(input layer)과 출력층(output layer)이라고 합니다.

![image-20220211164944659](C:\Users\dbw21\AppData\Roaming\Typora\typora-user-images\image-20220211164944659.png)

단층 퍼셉트론을 이용하면 AND, NAND, OR 게이트를 쉽게 구현할 수 있습니다. 게이트 연산에 쓰이는 것은 두 개의 입력값과 하나의 출력값입니다. 예를 들어 AND 게이트의 경우에는 두 개의 입력 값이 모두 1인 경우에만 출력값이 1이 나오는 구조를 갖고 있습니다.

하지만 단층 퍼셉트론으로 구현이 불가능한 게이트가 있는데 바로 XOR 게이트입니다. XOR 게이트는 입력값 두 개가 서로 다른 값을 갖고 있을때에만 출력값이 1이 되고, 입력값 두 개가 서로 같은 값을 가지면 출력값이 0이 되는 게이트입니다. 위의 파이썬 코드에 아무리 수많은 가중치와 편향을 넣어봐도 XOR 게이트를 구현하는 것은 불가능합니다. 그 이유는 단층 퍼셉트론은 직선 하나로 두 영역을 나눌 수 있는 문제에 대해서만 구현이 가능하기 때문입니다.

XOR 게이트는 직선이 아닌 곡선. 비선형 영역으로 분리하면 구현이 가능합니다. -> 다층 퍼셉트론으로 구현 가능.



### 3. 다층 퍼셉트론(MLP = MultiLayer Perceptron)

XOR 게이트는 기존의 AND, NAND, OR 게이트를 조합하면 만들 수 있습니다. 퍼셉트론 관점에서 말하면, 층을 더 쌓으면 만들 수 있습니다. 다층 퍼셉트론과 단층 퍼셉트론의 차이는 단층 퍼셉트론은 입력층과 출력층만 존재하지만, 다층 퍼셉트론은 중간에 층을 더 추가하였다는 점입니다. 이렇게 입력층과 출력층 사이에 존재하는 층을 **은닉층(hidden layer)**이라고 합니다. 즉, 다층 퍼셉트론은 중간에 은닉층이 존재한다는 점이 단층 퍼셉트론과 다릅니다. 다층 퍼셉트론은 줄여서 MLP라고도 부릅니다.

![image-20220211165136471](C:\Users\dbw21\AppData\Roaming\Typora\typora-user-images\image-20220211165136471.png)

위의 그림은 AND, NAND, OR 게이트를 조합하여 XOR 게이트를 구현한 다층 퍼셉트론의 예입니다. 

다층 퍼셉트론은 본래 은닉층이 1개 이상인 퍼셉트론을 말합니다. 즉, XOR 문제보다 더욱 복잡한 문제를 해결하기 위해서 다층 퍼셉트론은 중간에 수많은 은닉층을 더 추가할 수 있습니다. 은닉층의 개수는 2개일 수도 있고, 수십 개일수도 있고 사용자가 설정하기 나름입니다. 아래는 더 어려운 문제를 풀기 위해서 은닉층이 하나 더 추가되고(이 경우에는 은닉층이 2개), 뉴런의 개수를 늘린 다층 퍼셉트론의 모습을 보여줍니다.

![image-20220211165203087](C:\Users\dbw21\AppData\Roaming\Typora\typora-user-images\image-20220211165203087.png)

위와 같이 은닉층이 2개 이상인 신경망을 **심층 신경망(Deep Neural Network, DNN)**이라고 합니다. 심층 신경망은 다층 퍼셉트론만 이야기 하는 것이 아니라, 여러 변형된 다양한 신경망들도 은닉층이 2개 이상이 되면 심층 신경망이라고 합니다.

기계가 가중치를 스스로 찾아내도록 자동화시켜야하는데, 이것이 머신 러닝에서 말하는 **학습(training)** 단계에 해당됩니다. 앞서 선형 회귀와 로지스틱 회귀에서 보았듯이 **손실 함수(Loss function)**와 **옵티마이저(Optimizer)**를 사용합니다. 그리고 만약 **학습을 시키는 인공 신경망이 심층 신경망일 경우**에는 이를 심층 신경망을 학습시킨다고 하여, **딥 러닝(Deep Learning)**이라고 합니다.



# 04. 역전파(BackPropagation)

인공 신경망이 순전파 과정을 진행하여 예측값과 실제값의 오차를 계산하고 역전파 과정에서 경사 하강법을 사용하여 가중치를 업데이트한다.


인공 신경망의 학습은 오차를 최소화하는 가중치를 찾는 목적으로 순전파와 역전파를 반복하는 것을 말합니다.



# 06. 비선형 활성화 함수(Activation function)

비선형 활성화 함수(Activation function)는 입력을 받아 수학적 변환을 수행하고 출력을 생성하는 함수입니다. 앞서 배운 시그모이드 함수나 소프트맥스 함수는 대표적인 활성화 함수 중 하나입니다.

이번 챕터에서는 인공 신경망의 은닉층에서 왜 활성화 함수로 시그모이드(sigmoid) 함수를 사용하는 것을 왜 지양해야 하는지와 은닉층에서 주로 사용되는 함수인 렐루(ReLU) 함수를 소개하고 그 외의 다른 활성화 함수들에 대해서도 소개합니다.



### 1. 활성화 함수의 특징 - 비선형 함수(Nonlinear function)

**활성화 함수의 특징은 선형 함수가 아닌 비선형 함수여야 한다**는 점입니다. 선형 함수란 출력이 입력의 상수배만큼 변하는 함수를 선형함수라고 합니다. 예를 들어 f(x)=Wx+b라는 함수가 있을 때, W와 b는 상수입니다. 이 식은 그래프를 그리면 직선이 그려집니다.

인공 신경망의 능력을 높이기 위해서는 은닉층을 계속해서 추가해야 합니다. 그런데 **만약 활성화 함수로 선형 함수를 사용하게 되면 은닉층을 쌓을 수가 없습니다**. 예를 들어 활성화 함수로 선형 함수를 선택하고, 층을 계속 쌓는다고 가정해보겠습니다. 활성화 함수는 f(x)=Wx라고 가정합니다. 여기다가 은닉층을 두 개 추가한다고하면 출력층을 포함해서 y(x)=f(f(f(x)))가 됩니다. 이를 식으로 표현하면 W×W×W×x입니다. 그런데 이는 잘 생각해보면 W의 세 제곱값을 k라고 정의해버리면 y(x)=kx와 같이 다시 표현이 가능합니다. **즉, 선형 함수로는 은닉층을 여러번 추가하더라도 1회 추가한 것과 차이를 줄 수 없습니다.**

선형 함수를 사용한 은닉층을 1회 추가한 것과 연속으로 추가한 것이 차이가 없다는 뜻이지, 선형 함수를 사용한 층이 아무 의미가 없다는 뜻이 아닙니다. 학습 가능한 가중치가 새로 생긴다는 점에서 분명히 의미가 있습니다. 
이와 같이 **선형 함수를 사용한 층**을 활성화 함수를 사용하는 은닉층과 구분하기 위해서 **선형층(linear layer)이나 투사층(projection layer)** 등의 다른 표현을 사용하여 표현하기도 합니다. 
활성화 함수를 사용하는 일반적인 은닉층을 선형층과 대비되는 표현을 사용하면 비선형층(nonlinear layer)입니다.


### 2. 시그모이드 함수(Sigmoid function)와 기울기 소실

![image-20220211182235836](C:\Users\dbw21\AppData\Roaming\Typora\typora-user-images\image-20220211182235836.png)

위 인공 신경망의 학습 과정은 다음과 같습니다. 우선 인공 신경망은 입력에 대해서 순전파(forward propagation) 연산을 하고, 그리고 순전파 연산을 통해 나온 예측값과 실제값의 오차를 손실 함수(loss function)을 통해 계산하고, 그리고 이 **손실(loss)을 미분을 통해서 기울기(gradient)를 구하고**, 이를 통해 역전파(back propagation)를 수행합니다.

그리고 시그모이드 함수의 **문제점은 미분을 해서 기울기(gradient)를 구할 때 발생**합니다.

![image-20220211182319724](C:\Users\dbw21\AppData\Roaming\Typora\typora-user-images\image-20220211182319724.png)

시그모이드 함수의 출력값이 0 또는 1에 가까워지면, 기울기가 완만해지는 구간이 생긴다. 이 구간의 기울기는 0에 가까운 아주 작은 값이고 역전파 과정에서 이처럼 0에 가까운 아주 작은 기울기가 곱해지게 되면 앞단에는 기울기가 잘 전달되지 않게 된다. 이러한 현상을 **기울기 소실(Vanishing Gradient)** 문제라고 한다.

시그모이드 함수를 사용하는 은닉층의 개수가 다수가 될 경우에는 0에 가까운 기울기가 계속 곱해지면 앞단에서는 거의 기울기를 전파받을 수 없게 됩니다. **다시 말해 매개변수 W가 업데이트 되지 않아 학습이 되지를 않습니다**.

![image-20220211182525728](C:\Users\dbw21\AppData\Roaming\Typora\typora-user-images\image-20220211182525728.png)

위의 그림은 은닉층이 깊은 신경망에서 기울기 소실 문제로 인해 출력층과 가까운 은닉층에서는 기울기가 잘 전파되지만, 앞단으로 갈수록 기울기가 제대로 전파되지 않는 모습을 보여줍니다. 결론적으로 **시그모이드 함수를 은닉층에서 사용하는 것은 지양**됩니다.



### 3. 하이퍼볼릭탄젠트 함수(Hyperbolic tangent function)

하이퍼볼릭탄젠트 함수(tanh)는 입력값을 -1과 1사이의 값으로 변환합니다.

![image-20220211182612922](C:\Users\dbw21\AppData\Roaming\Typora\typora-user-images\image-20220211182612922.png)

하이퍼볼릭탄젠트 함수도 -1과 1에 가까운 출력값을 출력할 때, 시그모이드 함수와 같은 문제가 발생합니다. 그러나 하이퍼볼릭탄젠트 함수의 경우에는 시그모이드 함수와는 달리 0을 중심으로 하고 있는데, 이때문에 시그모이드 함수와 비교하면 반환값의 변화폭이 더 큽니다. 그래서 시그모이드 함수보다는 기울기 소실 증상이 적은 편입니다. 그래서 은닉층에서 시그모이드 함수보다는 많이 사용됩니다.



### 4. 렐루 함수(ReLU)

인공 신경망에서 가장 최고의 인기를 얻고 있는 함수입니다. 수식은 f(x)=max(0,x)로 아주 간단합니다.

![image-20220211182648693](C:\Users\dbw21\AppData\Roaming\Typora\typora-user-images\image-20220211182648693.png)

렐루 함수는 음수를 입력하면 0을 출력하고, 양수를 입력하면 입력값을 그대로 반환합니다. 렐루 함수는 특정 양수값에 수렴하지 않으므로 깊은 신경망에서 시그모이드 함수보다 훨씬 더 잘 작동합니다. 뿐만 아니라, 렐루 함수는 시그모이드 함수와 하이퍼볼릭탄젠트 함수와 같이 어떤 연산이 필요한 것이 아니라 단순 임계값이므로 연산 속도도 빠릅니다.

하지만 여전히 문제점이 존재하는데, 입력값이 음수면 기울기도 0이 됩니다. 그리고 이 뉴런은 다시 회생하는 것이 매우 어렵습니다. 이 문제를 죽은 렐루(dying ReLU)라고 합니다.



### 5. 리키 렐루(Leaky ReLU)

죽은 렐루를 보완하기 위해 ReLU의 변형 함수들이 등장하기 시작했습니다. 변형 함수는 Leaky ReLU외에도 여러 개가 있다. Leaky ReLU는 입력값이 음수일 경우에 0이 아니라 0.001과 같은 매우 작은 수를 반환하도록 되어있습니다.

수식은 f(x)=max(ax,x)로 아주 간단합니다. a는 하이퍼파라미터로 Leaky('새는') 정도를 결정하며 일반적으로는 0.01의 값을 가집니다. 여기서 말하는 '새는 정도'라는 것은 입력값의 음수일 때의 기울기를 비유하고 있습니다.

![image-20220211182759854](C:\Users\dbw21\AppData\Roaming\Typora\typora-user-images\image-20220211182759854.png)

위의 그래프에서는 새는 모습을 확실히 보여주기 위해 a를 0.1로 잡았습니다. 위와 같이 입력값이 음수라도 기울기가 0이 되지 않으면 ReLU는 죽지 않습니다.



### 6. 소프트맥스 함수(Softmax function)

**은닉층에서 ReLU(또는 ReLU 변형) 함수들을 사용**하는 것이 일반적이지만 그렇다고 해서 앞서 배운 시그모이드 함수나 소프트맥스 함수가 사용되지 않는다는 의미는 아닙니다. 분류 문제를 풀때, 로지스틱 회귀와 소프트맥스 회귀를 출력층에 적용하여 사용합니다.

![image-20220211182840650](C:\Users\dbw21\AppData\Roaming\Typora\typora-user-images\image-20220211182840650.png)

**소프트맥스 함수는 시그모이드 함수처럼 출력층의 뉴런에서 주로 사용**되는데, 시그모이드 함수가 두 가지 선택지 중 하나를 고르는 이진 분류 (Binary Classification) 문제에 사용된다면 세 가지 이상의 (상호 배타적인) 선택지 중 하나를 고르는 다중 클래스 분류(MultiClass Classification) 문제에 주로 사용됩니다.



### 7. 출력층의 활성화 함수와 오차 함수의 관계

은닉층의 활성화 함수로는 ReLU 또는 Leaky ReLU와 같은 ReLU의 변형을 사용하라고 정리해봤습니다. 그렇다면 출력층은 어떨까요? 각 문제에 따른 출력층의 활성화 함수와 비용 함수의 관계를 정리해보면 다음과 같습니다. 이 외에도 다중 레이블 분류도 있지만 여기서는 다루지 않겠습니다.

| 문제             | 활성화 함수 | 비용 함수             |
| :--------------- | :---------- | :-------------------- |
| 이진 분류        | 시그모이드  | nn.BCELoss()          |
| 다중 클래스 분류 | 소프트맥스  | nn.CrossEntropyLoss() |
| 회귀             | 없음        | MSE                   |

* 주의할 점은 nn.CrossEntropyLoss()는 소프트맥스 함수를 이미 포함하고 있습니다.



cf.

- 시그모이드 함수의 또 다른 문제점은 원점 중심이 아니라는 점입니다(Not zero-centered). 따라서, 평균이 0이 아니라 0.5이며, 시그모이드 함수는 항상 양수를 출력하기 때문에 출력의 가중치 합이 입력의 가중치 합보다 커질 가능성이 높습니다. 이것을 편향 이동(bias shift)이라 하며, 이러한 이유로 각 레이어를 지날 때마다 분산이 계속 커져 가장 높은 레이어에서는 활성화 함수의 출력이 0이나 1로 수렴하게 되어 기울기 소실 문제가 일어날 수 있습니다.
- 하이퍼볼릭탄젠트 함수는 원점 중심(zero-centered)이기 때문에, 시그모이드와 달리 편향 이동은 일어나지 않습니다. 하지만, 하이퍼볼릭탄젠트 함수 또한 입력의 절대값이 클 경우 -1이나 1로 수렴하게 되는데 시그모이드 함수와 마찬가지로 이때 기울기가 완만해지므로 역시나 기울기 소실 문제가 일어날 수 있습니다.

- 스탠포드 대학교의 딥 러닝 강의 cs231n에서는 은닉층의 활성화 함수로 ReLU를 먼저 시도해보고, 그다음으로 LeakyReLU나 ELU 같은 ReLU의 변형들을 시도해보며, sigmoid는 사용하지 말라고 권장합니다.

